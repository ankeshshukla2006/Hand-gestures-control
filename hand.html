<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Fast Hand Gesture Particle Controller</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
    html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #0b0f1a;
        font-family: 'Arial', sans-serif;
    }

    canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 2;
    }

    #video {
        position: absolute;
        top: 0;
        left: 0;
        width: 320px;
        height: 240px;
        z-index: 1;
        border: 2px solid #00ff88;
        border-radius: 10px;
        margin: 10px;
        transform: scaleX(-1);
        opacity: 0.7;
    }

    #controls {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(10, 15, 30, 0.9);
        color: white;
        padding: 15px;
        border-radius: 10px;
        z-index: 3;
        min-width: 200px;
        backdrop-filter: blur(5px);
        border: 1px solid rgba(0, 255, 136, 0.3);
    }

    #controls h3 {
        margin-top: 0;
        color: #00ff88;
        text-align: center;
        font-size: 16px;
    }

    .slider-container {
        margin: 10px 0;
    }

    .slider-container label {
        display: block;
        font-size: 12px;
        margin-bottom: 5px;
        color: #88ffcc;
    }

    input[type="range"] {
        width: 100%;
        height: 4px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 2px;
        outline: none;
        -webkit-appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 15px;
        height: 15px;
        border-radius: 50%;
        background: #00ff88;
        cursor: pointer;
    }

    #gestureDisplay {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px 20px;
        border-radius: 20px;
        z-index: 3;
        font-size: 14px;
        text-align: center;
        border: 1px solid rgba(0, 255, 136, 0.3);
    }

    #gestureDisplay span {
        color: #00ff88;
        font-weight: bold;
    }

    #fpsCounter {
        position: absolute;
        top: 10px;
        left: 340px;
        color: #88ffcc;
        font-size: 12px;
        z-index: 3;
        background: rgba(0, 0, 0, 0.5);
        padding: 5px 10px;
        border-radius: 10px;
    }

    .pattern-badge {
        display: inline-block;
        background: rgba(0, 255, 136, 0.2);
        color: #00ff88;
        padding: 3px 8px;
        border-radius: 12px;
        font-size: 12px;
        margin-left: 10px;
        border: 1px solid rgba(0, 255, 136, 0.3);
    }
</style>
</head>

<body>
    <video id="video" playsinline></video>
    <canvas id="canvas"></canvas>
    
    <div id="controls">
        <h3>Particle Settings</h3>
        <div class="slider-container">
            <label>Particle Count: <span id="countValue">300</span></label>
            <input type="range" id="particleCount" min="100" max="1000" value="300" step="50">
        </div>
        <div class="slider-container">
            <label>Particle Speed: <span id="speedValue">2.0</span>x</label>
            <input type="range" id="particleSpeed" min="0.5" max="5" value="2.0" step="0.1">
        </div>
        <div class="slider-container">
            <label>Particle Size: <span id="sizeValue">2.0</span></label>
            <input type="range" id="particleSize" min="1" max="5" value="2.0" step="0.5">
        </div>
        <div class="slider-container">
            <label>Connection Distance: <span id="distValue">80</span></label>
            <input type="range" id="connectionDist" min="30" max="200" value="80" step="10">
        </div>
    </div>
    
    <div id="fpsCounter">FPS: 60</div>
    
    <div id="gestureDisplay">
        Gesture: <span id="gestureText">No hand detected</span>
        <div id="patternBadge" class="pattern-badge" style="display: none;"></div>
    </div>

    <!-- MediaPipe imports -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d", { alpha: false });
        const video = document.getElementById("video");
        
        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // High-performance settings
        canvas.style.imageRendering = 'optimizeSpeed';
        ctx.imageSmoothingEnabled = false;
        
        // Configuration with optimized defaults
        const config = {
            particleCount: 300,
            particleSpeed: 2.0,
            particleSize: 2.0,
            connectionDistance: 80,
            repulsionStrength: 0.5,
            trailEffect: 0.2
        };
        
        // Update UI values
        function updateUI() {
            document.getElementById('countValue').textContent = config.particleCount;
            document.getElementById('speedValue').textContent = config.particleSpeed.toFixed(1);
            document.getElementById('sizeValue').textContent = config.particleSize.toFixed(1);
            document.getElementById('distValue').textContent = config.connectionDistance;
        }
        
        // Initialize UI controls
        document.getElementById('particleCount').addEventListener('input', function() {
            config.particleCount = parseInt(this.value);
            updateUI();
            initParticles();
        });
        
        document.getElementById('particleSpeed').addEventListener('input', function() {
            config.particleSpeed = parseFloat(this.value);
            updateUI();
        });
        
        document.getElementById('particleSize').addEventListener('input', function() {
            config.particleSize = parseFloat(this.value);
            updateUI();
        });
        
        document.getElementById('connectionDist').addEventListener('input', function() {
            config.connectionDistance = parseInt(this.value);
            updateUI();
        });
        
        updateUI();
        
        // Hand tracking variables
        let handDetected = false;
        let handPosition = { x: canvas.width / 2, y: canvas.height / 2 };
        let currentGesture = null;
        let activePattern = 'idle';
        
        // Initialize MediaPipe Hands with optimized settings
        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0, // Lower complexity for better performance
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handDetected = true;
                const landmarks = results.multiHandLandmarks[0];
                
                // Get hand center (wrist position)
                const wrist = landmarks[0];
                handPosition = {
                    x: (1 - wrist.x) * canvas.width,
                    y: wrist.y * canvas.height
                };
                
                // Detect gesture
                currentGesture = detectFastGesture(landmarks);
                updateGestureDisplay();
            } else {
                handDetected = false;
                currentGesture = null;
                activePattern = 'idle';
                updateGestureDisplay();
            }
        });
        
        // Optimized gesture detection
        function detectFastGesture(landmarks) {
            const fingerTips = [8, 12, 16, 20]; // Index, Middle, Ring, Pinky
            const fingerJoints = [6, 10, 14, 18];
            
            let extendedFingers = 0;
            
            // Check four main fingers
            for (let i = 0; i < 4; i++) {
                const tip = landmarks[fingerTips[i]];
                const joint = landmarks[fingerJoints[i]];
                if (tip.y < joint.y - 0.05) extendedFingers++;
            }
            
            // Check thumb (simplified)
            const thumbTip = landmarks[4];
            const thumbJoint = landmarks[3];
            if (thumbTip.x > thumbJoint.x + 0.05) extendedFingers++;
            
            // Set active pattern based on finger count
            switch(extendedFingers) {
                case 0: activePattern = 'attract'; return 'Fist';
                case 1: activePattern = 'follow'; return 'One finger';
                case 2: activePattern = 'circle'; return 'Two fingers';
                case 3: activePattern = 'wave'; return 'Three fingers';
                case 4: activePattern = 'spiral'; return 'Four fingers';
                case 5: activePattern = 'grid'; return 'Five fingers';
                default: activePattern = 'idle'; return 'Unknown';
            }
        }
        
        function updateGestureDisplay() {
            const gestureText = document.getElementById('gestureText');
            const patternBadge = document.getElementById('patternBadge');
            
            if (handDetected && currentGesture) {
                gestureText.textContent = currentGesture;
                patternBadge.textContent = activePattern;
                patternBadge.style.display = 'inline-block';
                
                // Update badge color based on pattern
                const colors = {
                    'attract': '#ff5555',
                    'follow': '#55aaff',
                    'circle': '#55ff55',
                    'wave': '#ff55ff',
                    'spiral': '#ffff55',
                    'grid': '#ffaa55',
                    'idle': '#888888'
                };
                patternBadge.style.color = colors[activePattern] || '#00ff88';
                patternBadge.style.borderColor = colors[activePattern] || '#00ff88';
            } else {
                gestureText.textContent = 'No hand detected';
                patternBadge.style.display = 'none';
            }
        }
        
        // Start camera with optimized settings
        const camera = new Camera(video, {
            onFrame: async () => {
                await hands.send({ image: video });
            },
            width: 320,
            height: 240
        });
        
        camera.start();
        
        /* ===== HIGH-PERFORMANCE PARTICLE CLASS ===== */
        class Particle {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.vx = 0;
                this.vy = 0;
                this.ox = this.x; // Original position for reset
                this.oy = this.y;
                this.size = Math.random() * config.particleSize + 1;
                this.speed = Math.random() * 0.1 + 0.05;
                this.color = this.getRandomColor();
                this.angle = Math.random() * Math.PI * 2;
                this.distance = Math.random() * 150 + 50;
                this.patternAngle = 0;
                this.phase = Math.random() * Math.PI * 2;
            }
            
            getRandomColor() {
                const colors = [
                    '#ff5555', '#55ff55', '#5555ff', '#ffff55', '#ff55ff', '#55ffff',
                    '#ff8855', '#55ff88', '#8855ff', '#ff55aa', '#aaff55', '#55aaff'
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            update() {
                // Store previous position for trail effect
                this.px = this.x;
                this.py = this.y;
                
                if (!handDetected) {
                    // Return to original position
                    this.vx += (this.ox - this.x) * 0.02;
                    this.vy += (this.oy - this.y) * 0.02;
                } else {
                    // Apply pattern behavior
                    this.applyPattern();
                }
                
                // Apply velocity
                this.x += this.vx * config.particleSpeed;
                this.y += this.vy * config.particleSpeed;
                
                // Apply friction
                this.vx *= 0.95;
                this.vy *= 0.95;
                
                // Keep particles within bounds with bounce
                if (this.x < 0) { this.x = 0; this.vx = Math.abs(this.vx) * 0.8; }
                if (this.x > canvas.width) { this.x = canvas.width; this.vx = -Math.abs(this.vx) * 0.8; }
                if (this.y < 0) { this.y = 0; this.vy = Math.abs(this.vy) * 0.8; }
                if (this.y > canvas.height) { this.y = canvas.height; this.vy = -Math.abs(this.vy) * 0.8; }
            }
            
            applyPattern() {
                switch(activePattern) {
                    case 'attract': // Fist - strong attraction
                        const dx = handPosition.x - this.x;
                        const dy = handPosition.y - this.y;
                        const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                        this.vx += (dx / dist) * this.speed * 0.3;
                        this.vy += (dy / dist) * this.speed * 0.3;
                        break;
                        
                    case 'follow': // One finger - follow with offset
                        const angle = Math.atan2(handPosition.y - this.y, handPosition.x - this.x);
                        const followDist = 50;
                        this.vx += Math.cos(angle) * this.speed * 0.2;
                        this.vy += Math.sin(angle) * this.speed * 0.2;
                        break;
                        
                    case 'circle': // Two fingers - fast circular motion
                        this.patternAngle += 0.08 * config.particleSpeed;
                        const targetX = handPosition.x + Math.cos(this.patternAngle + this.phase) * this.distance;
                        const targetY = handPosition.y + Math.sin(this.patternAngle + this.phase) * this.distance;
                        this.vx += (targetX - this.x) * 0.1;
                        this.vy += (targetY - this.y) * 0.1;
                        break;
                        
                    case 'wave': // Three fingers - wave pattern
                        this.patternAngle += 0.05 * config.particleSpeed;
                        const waveX = handPosition.x + Math.cos(this.phase) * 300;
                        const waveY = handPosition.y + Math.sin(this.patternAngle * 2 + this.phase) * 100;
                        this.vx += (waveX - this.x) * 0.08;
                        this.vy += (waveY - this.y) * 0.08;
                        break;
                        
                    case 'spiral': // Four fingers - spiral pattern
                        this.patternAngle += 0.06 * config.particleSpeed;
                        const spiralRadius = this.patternAngle * 3;
                        const spiralX = handPosition.x + Math.cos(this.patternAngle + this.phase) * spiralRadius;
                        const spiralY = handPosition.y + Math.sin(this.patternAngle + this.phase) * spiralRadius;
                        this.vx += (spiralX - this.x) * 0.07;
                        this.vy += (spiralY - this.y) * 0.07;
                        break;
                        
                    case 'grid': // Five fingers - grid alignment
                        const gridSize = 40;
                        const gridX = Math.round(this.x / gridSize) * gridSize;
                        const gridY = Math.round(this.y / gridSize) * gridSize;
                        this.vx += (gridX - this.x) * 0.15;
                        this.vy += (gridY - this.y) * 0.15;
                        break;
                        
                    default: // Idle - gentle movement toward hand
                        const idleDx = handPosition.x - this.x;
                        const idleDy = handPosition.y - this.y;
                        this.vx += idleDx * 0.01;
                        this.vy += idleDy * 0.01;
                }
            }
            
            draw() {
                // Draw trail
                if (this.px && this.py) {
                    ctx.strokeStyle = this.color + '40';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(this.px, this.py);
                    ctx.lineTo(this.x, this.y);
                    ctx.stroke();
                }
                
                // Draw particle
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Add glow effect
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }
        
        /* ===== PARTICLE MANAGEMENT ===== */
        let particles = [];
        
        function initParticles() {
            particles = [];
            for (let i = 0; i < config.particleCount; i++) {
                particles.push(new Particle());
            }
        }
        
        initParticles();
        
        /* ===== OPTIMIZED CONNECTION DRAWING ===== */
        function drawConnections() {
            const maxDistSq = config.connectionDistance * config.connectionDistance;
            
            // Use spatial partitioning for better performance
            for (let i = 0; i < particles.length; i++) {
                const p1 = particles[i];
                
                // Only check nearby particles
                for (let j = i + 1; j < particles.length; j++) {
                    const p2 = particles[j];
                    const dx = p1.x - p2.x;
                    const dy = p1.y - p2.y;
                    const distSq = dx*dx + dy*dy;
                    
                    if (distSq < maxDistSq) {
                        const opacity = 1 - Math.sqrt(distSq) / config.connectionDistance;
                        ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.1})`;
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                    }
                }
            }
        }
        
        /* ===== HIGH-PERFORMANCE ANIMATION LOOP ===== */
        let lastTime = 0;
        let frameCount = 0;
        let fps = 60;
        
        function animate(currentTime) {
            // Calculate FPS
            frameCount++;
            if (currentTime - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = currentTime;
                document.getElementById('fpsCounter').textContent = `FPS: ${fps}`;
            }
            
            // Clear canvas efficiently
            ctx.fillStyle = `rgba(11, 15, 26, ${config.trailEffect})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update particles in batches for better performance
            for (let i = 0; i < particles.length; i++) {
                particles[i].update();
            }
            
            // Draw connections
            drawConnections();
            
            // Draw particles
            for (let i = 0; i < particles.length; i++) {
                particles[i].draw();
            }
            
            // Draw hand position indicator
            if (handDetected) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(handPosition.x, handPosition.y, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Add pulsing effect
                const pulseSize = 12 + Math.sin(currentTime * 0.01) * 4;
                ctx.strokeStyle = 'rgba(0, 255, 136, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(handPosition.x, handPosition.y, pulseSize, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            requestAnimationFrame(animate);
        }
        
        /* ===== RESIZE HANDLER ===== */
        window.addEventListener("resize", () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initParticles();
        });
        
        // Start animation
        animate(0);
    </script>
</body>
</html>