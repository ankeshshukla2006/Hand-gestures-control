<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Precision Hand Gesture Particle Controller</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
    html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #0a0e1a;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        touch-action: none;
    }

    canvas {
        display: block;
        position: fixed;
        top: 0;
        left: 0;
        z-index: 1;
        image-rendering: -webkit-optimize-contrast;
        image-rendering: crisp-edges;
    }

    #video {
        position: fixed;
        top: 10px;
        left: 10px;
        width: 280px;
        height: 210px;
        z-index: 2;
        border: 3px solid #00ffaa;
        border-radius: 12px;
        transform: scaleX(-1);
        opacity: 0.9;
        box-shadow: 0 0 20px rgba(0, 255, 170, 0.3);
        background: #000;
    }

    #stats {
        position: fixed;
        top: 10px;
        right: 10px;
        background: rgba(10, 15, 30, 0.95);
        color: white;
        padding: 15px;
        border-radius: 10px;
        z-index: 3;
        min-width: 220px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(0, 255, 170, 0.4);
        font-size: 13px;
    }

    #stats h3 {
        margin: 0 0 10px 0;
        color: #00ffaa;
        font-size: 16px;
        text-align: center;
    }

    .stat-item {
        display: flex;
        justify-content: space-between;
        margin: 6px 0;
        padding: 3px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .stat-value {
        color: #00ffaa;
        font-weight: bold;
    }

    #gestureDisplay {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 12px 25px;
        border-radius: 25px;
        z-index: 3;
        font-size: 15px;
        text-align: center;
        border: 2px solid #00ffaa;
        box-shadow: 0 0 20px rgba(0, 255, 170, 0.3);
        backdrop-filter: blur(10px);
        min-width: 300px;
    }

    #gestureIcon {
        font-size: 24px;
        margin-right: 10px;
        vertical-align: middle;
    }

    #gestureText {
        color: #00ffaa;
        font-weight: bold;
        vertical-align: middle;
    }

    #loading {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #0a0e1a;
        z-index: 100;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: #00ffaa;
        font-size: 24px;
        text-align: center;
        backdrop-filter: blur(10px);
        transition: opacity 0.5s ease;
    }

    #loadingContent {
        background: rgba(10, 15, 30, 0.95);
        padding: 40px;
        border-radius: 20px;
        border: 2px solid #00ffaa;
        max-width: 500px;
    }

    .instructions {
        position: fixed;
        top: 230px;
        left: 10px;
        background: rgba(10, 15, 30, 0.9);
        color: white;
        padding: 12px;
        border-radius: 10px;
        z-index: 3;
        font-size: 12px;
        max-width: 260px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(0, 255, 170, 0.3);
    }

    .instructions h4 {
        margin: 0 0 8px 0;
        color: #00ffaa;
        font-size: 14px;
    }

    .instructions li {
        margin: 4px 0;
        padding-left: 5px;
    }

    #performanceWarning {
        display: none;
        position: fixed;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(255, 100, 100, 0.9);
        color: white;
        padding: 10px 20px;
        border-radius: 10px;
        z-index: 3;
        text-align: center;
        max-width: 400px;
    }
</style>
</head>

<body>
    <div id="loading">
        <div id="loadingContent">
            <div>Loading Hand Tracking...</div>
            <div style="font-size: 16px; margin-top: 10px;">Please allow camera access</div>
            <div style="font-size: 14px; margin-top: 20px; color: #88ffcc;">Make sure you have good lighting</div>
            <div id="loadingProgress" style="margin-top: 20px; font-size: 14px; color: #00ffaa;">Starting...</div>
        </div>
    </div>

    <video id="video" playsinline></video>
    <canvas id="canvas"></canvas>
    
    <div id="stats">
        <h3>Performance Stats</h3>
        <div class="stat-item">
            <span>FPS:</span>
            <span class="stat-value" id="fpsCounter">0</span>
        </div>
        <div class="stat-item">
            <span>Particles:</span>
            <span class="stat-value" id="particleCounter">0</span>
        </div>
        <div class="stat-item">
            <span>Gesture Accuracy:</span>
            <span class="stat-value" id="accuracyCounter">Low</span>
        </div>
        <div class="stat-item">
            <span>Tracking:</span>
            <span class="stat-value" id="trackingStatus">Loading</span>
        </div>
        <div class="stat-item">
            <span>Pattern:</span>
            <span class="stat-value" id="patternDisplay">Idle</span>
        </div>
    </div>

    <div class="instructions">
        <h4>Gesture Controls:</h4>
        <ul>
            <li><strong>‚úä Fist:</strong> Attract particles</li>
            <li><strong>üëÜ 1 Finger:</strong> Follow fingertip</li>
            <li><strong>‚úåÔ∏è 2 Fingers:</strong> Circle pattern</li>
            <li><strong>ü§ü 3 Fingers:</strong> Wave pattern</li>
            <li><strong>üñêÔ∏è 4 Fingers:</strong> Spiral pattern</li>
            <li><strong>üëê 5 Fingers:</strong> Grid pattern</li>
        </ul>
        <div style="margin-top: 8px; font-size: 11px; color: #88ffcc;">
            Tip: Keep hand steady for better accuracy
        </div>
    </div>

    <div id="gestureDisplay">
        <span id="gestureIcon">üñêÔ∏è</span>
        <span id="gestureText">Initializing...</span>
    </div>

    <div id="performanceWarning">
        ‚ö†Ô∏è Performance may be affected. Close other tabs for better experience.
    </div>

    <!-- MediaPipe with high accuracy settings -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        // Global variables
        let canvas, ctx;
        let particles = [];
        let handDetected = false;
        let handPosition = { x: 0, y: 0 };
        let currentGesture = null;
        let activePattern = 'idle';
        let gestureConfidence = 0;
        let frameCount = 0;
        let lastFpsUpdate = 0;
        let fps = 0;
        let lowFpsCount = 0;
        let animationId = null;
        let smoothedHandPosition = { x: 0, y: 0 };
        const smoothingFactor = 0.2;
        
        // Initialize everything after page loads
        window.addEventListener('load', init);

        async function init() {
            console.log("Starting initialization...");
            
            // Setup canvas first
            canvas = document.getElementById("canvas");
            ctx = canvas.getContext("2d", { 
                alpha: false,
                desynchronized: true
            });
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Update loading text
            document.getElementById('loadingProgress').textContent = "Setting up canvas...";
            
            // Create particles immediately
            createParticles(400);
            
            // Start animation loop immediately
            startAnimation();
            
            // Update loading text
            document.getElementById('loadingProgress').textContent = "Animation started, initializing camera...";
            
            // Try to initialize hand tracking
            try {
                await initHandTracking();
                document.getElementById('loadingProgress').textContent = "Hand tracking ready!";
                
                // Hide loading screen after success
                setTimeout(() => {
                    document.getElementById('loading').style.opacity = '0';
                    setTimeout(() => {
                        document.getElementById('loading').style.display = 'none';
                    }, 500);
                }, 1000);
                
            } catch (error) {
                console.error("Hand tracking failed:", error);
                document.getElementById('loadingProgress').textContent = "Camera not available, using mouse control";
                document.getElementById('loadingProgress').style.color = "#ffaa00";
                
                // Setup mouse control as fallback
                setupMouseControl();
                
                // Still hide loading screen
                setTimeout(() => {
                    document.getElementById('loading').style.opacity = '0';
                    setTimeout(() => {
                        document.getElementById('loading').style.display = 'none';
                    }, 500);
                }, 1500);
            }
            
            // Update display
            updateDisplay();
        }
        
        function createParticles(count) {
            particles = [];
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5,
                    size: Math.random() * 1.5 + 1,
                    baseSpeed: 0.05 + Math.random() * 0.05,
                    hue: Math.random() * 60 + 180,
                    saturation: 70 + Math.random() * 30,
                    lightness: 50 + Math.random() * 30,
                    patternAngle: Math.random() * Math.PI * 2,
                    patternRadius: 50 + Math.random() * 100,
                    waveOffset: Math.random() * Math.PI * 2,
                    phaseOffset: Math.random() * Math.PI * 2,
                    gridAnchor: { 
                        x: Math.floor(Math.random() * 20) * 30 + 15,
                        y: Math.floor(Math.random() * 20) * 30 + 15
                    }
                });
            }
            document.getElementById('particleCounter').textContent = particles.length;
        }
        
        function startAnimation() {
            function animate(currentTime) {
                // Calculate FPS
                frameCount++;
                if (currentTime - lastFpsUpdate >= 1000) {
                    fps = Math.round(frameCount * 0.3 + fps * 0.7);
                    frameCount = 0;
                    lastFpsUpdate = currentTime;
                    document.getElementById('fpsCounter').textContent = fps;
                    
                    // Performance warning
                    if (fps < 30) {
                        lowFpsCount++;
                        if (lowFpsCount > 5) {
                            document.getElementById('performanceWarning').style.display = 'block';
                        }
                    } else {
                        lowFpsCount = 0;
                        document.getElementById('performanceWarning').style.display = 'none';
                    }
                }
                
                // Clear canvas with trail effect
                ctx.fillStyle = 'rgba(10, 14, 26, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Update particles
                updateParticles();
                
                // Draw connections
                drawConnections();
                
                // Draw particles
                drawParticles();
                
                // Draw hand position indicator
                if (handDetected) {
                    drawHandIndicator();
                }
                
                // Continue animation
                animationId = requestAnimationFrame(animate);
            }
            
            animationId = requestAnimationFrame(animate);
        }
        
        function updateParticles() {
            // If no hand detected, do gentle random motion
            if (!handDetected) {
                particles.forEach(p => {
                    p.vx += (Math.random() - 0.5) * 0.02;
                    p.vy += (Math.random() - 0.5) * 0.02;
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vx *= 0.96;
                    p.vy *= 0.96;
                    
                    // Boundary handling
                    if (p.x < -50) p.x = canvas.width + 50;
                    if (p.x > canvas.width + 50) p.x = -50;
                    if (p.y < -50) p.y = canvas.height + 50;
                    if (p.y > canvas.height + 50) p.y = -50;
                    
                    // Update color
                    p.hue = (p.hue + 0.2) % 360;
                });
                return;
            }
            
            // Apply pattern behavior
            const targetX = smoothedHandPosition.x || canvas.width / 2;
            const targetY = smoothedHandPosition.y || canvas.height / 2;
            
            particles.forEach(p => {
                switch(activePattern) {
                    case 'attract':
                        const dx = targetX - p.x;
                        const dy = targetY - p.y;
                        const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                        const force = 0.3 / (dist * 0.01 + 1);
                        p.vx += (dx / dist) * force;
                        p.vy += (dy / dist) * force;
                        break;
                        
                    case 'follow':
                        p.vx += (targetX - p.x) * 0.02;
                        p.vy += (targetY - p.y) * 0.02;
                        break;
                        
                    case 'circle':
                        p.patternAngle += 0.04;
                        const circleX = targetX + Math.cos(p.patternAngle + p.phaseOffset) * p.patternRadius;
                        const circleY = targetY + Math.sin(p.patternAngle + p.phaseOffset) * p.patternRadius;
                        p.vx += (circleX - p.x) * 0.1;
                        p.vy += (circleY - p.y) * 0.1;
                        break;
                        
                    case 'wave':
                        p.patternAngle += 0.03;
                        const waveX = targetX + Math.cos(p.waveOffset) * 200;
                        const waveY = targetY + Math.sin(p.patternAngle * 2 + p.waveOffset) * 80;
                        p.vx += (waveX - p.x) * 0.08;
                        p.vy += (waveY - p.y) * 0.08;
                        break;
                        
                    case 'spiral':
                        p.patternAngle += 0.05;
                        const spiralR = p.patternAngle * 2;
                        const spiralX = targetX + Math.cos(p.patternAngle + p.phaseOffset) * spiralR;
                        const spiralY = targetY + Math.sin(p.patternAngle + p.phaseOffset) * spiralR;
                        p.vx += (spiralX - p.x) * 0.07;
                        p.vy += (spiralY - p.y) * 0.07;
                        break;
                        
                    case 'grid':
                        const gridX = targetX + p.gridAnchor.x;
                        const gridY = targetY + p.gridAnchor.y;
                        p.vx += (gridX - p.x) * 0.15;
                        p.vy += (gridY - p.y) * 0.15;
                        break;
                }
                
                // Apply velocity and friction
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.96;
                p.vy *= 0.96;
                
                // Boundary handling
                if (p.x < -50) p.x = canvas.width + 50;
                if (p.x > canvas.width + 50) p.x = -50;
                if (p.y < -50) p.y = canvas.height + 50;
                if (p.y > canvas.height + 50) p.y = -50;
                
                // Update color
                p.hue = (p.hue + 0.2) % 360;
            });
        }
        
        function drawConnections() {
            const connectionDistance = 100;
            const connectionDistanceSq = connectionDistance * connectionDistance;
            
            for (let i = 0; i < particles.length; i++) {
                const p1 = particles[i];
                
                for (let j = i + 1; j < Math.min(i + 20, particles.length); j++) {
                    const p2 = particles[j];
                    const dx = p1.x - p2.x;
                    const dy = p1.y - p2.y;
                    const distSq = dx * dx + dy * dy;
                    
                    if (distSq < connectionDistanceSq) {
                        const distance = Math.sqrt(distSq);
                        const alpha = 0.2 * (1 - distance / connectionDistance);
                        
                        ctx.strokeStyle = `rgba(100, 255, 200, ${alpha})`;
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                    }
                }
            }
        }
        
        function drawParticles() {
            particles.forEach(p => {
                // Draw particle with gradient
                const gradient = ctx.createRadialGradient(
                    p.x, p.y, 0,
                    p.x, p.y, p.size * 3
                );
                gradient.addColorStop(0, `hsla(${p.hue}, ${p.saturation}%, ${p.lightness + 20}%, 1)`);
                gradient.addColorStop(1, `hsla(${p.hue}, ${p.saturation}%, ${p.lightness}%, 0)`);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function drawHandIndicator() {
            const targetX = smoothedHandPosition.x || canvas.width / 2;
            const targetY = smoothedHandPosition.y || canvas.height / 2;
            
            // Outer glow
            ctx.shadowColor = '#00ffaa';
            ctx.shadowBlur = 20;
            ctx.fillStyle = 'rgba(0, 255, 170, 0.3)';
            ctx.beginPath();
            ctx.arc(targetX, targetY, 25, 0, Math.PI * 2);
            ctx.fill();
            
            // Inner circle
            ctx.shadowBlur = 10;
            ctx.fillStyle = '#00ffaa';
            ctx.beginPath();
            ctx.arc(targetX, targetY, 8, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowBlur = 0;
            
            // Draw current gesture indicator
            if (currentGesture) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(currentGesture.charAt(0), targetX, targetY - 40);
            }
        }
        
        async function initHandTracking() {
            const video = document.getElementById("video");
            
            const hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7,
                selfieMode: true
            });
            
            hands.onResults((results) => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    handDetected = true;
                    const landmarks = results.multiHandLandmarks[0];
                    
                    // Use multiple points for better accuracy
                    const wrist = landmarks[0];
                    const middleBase = landmarks[9];
                    
                    // Weighted average for better accuracy
                    handPosition = {
                        x: (wrist.x * 0.3 + middleBase.x * 0.7) * canvas.width,
                        y: (wrist.y * 0.3 + middleBase.y * 0.7) * canvas.height
                    };
                    
                    // Apply smoothing
                    if (!smoothedHandPosition.x) {
                        smoothedHandPosition = { ...handPosition };
                    } else {
                        smoothedHandPosition.x += (handPosition.x - smoothedHandPosition.x) * smoothingFactor;
                        smoothedHandPosition.y += (handPosition.y - smoothedHandPosition.y) * smoothingFactor;
                    }
                    
                    // Flip horizontally for mirror effect
                    smoothedHandPosition.x = canvas.width - smoothedHandPosition.x;
                    
                    // Detect gesture
                    const { gesture, confidence } = detectHighAccuracyGesture(landmarks);
                    currentGesture = gesture;
                    gestureConfidence = confidence;
                    
                    // Set active pattern
                    switch(gesture) {
                        case 'Fist': activePattern = 'attract'; break;
                        case 'One finger': activePattern = 'follow'; break;
                        case 'Two fingers': activePattern = 'circle'; break;
                        case 'Three fingers': activePattern = 'wave'; break;
                        case 'Four fingers': activePattern = 'spiral'; break;
                        case 'Five fingers': activePattern = 'grid'; break;
                        default: activePattern = 'idle';
                    }
                    
                } else {
                    handDetected = false;
                    currentGesture = null;
                    activePattern = 'idle';
                    gestureConfidence = 0;
                }
                
                updateDisplay();
            });
            
            const camera = new Camera(video, {
                onFrame: async () => {
                    try {
                        await hands.send({ image: video });
                    } catch (e) {
                        console.log("Camera frame error:", e);
                    }
                },
                width: 320,
                height: 240
            });
            
            await camera.start();
        }
        
        function detectHighAccuracyGesture(landmarks) {
            const tips = [4, 8, 12, 16, 20];
            const joints = [2, 6, 10, 14, 18];
            
            let extendedCount = 0;
            let confidenceScore = 0;
            
            for (let i = 0; i < tips.length; i++) {
                const tip = landmarks[tips[i]];
                const joint = landmarks[joints[i]];
                
                if (i === 0) {
                    const thumbExtended = tip.x < joint.x - 0.08;
                    if (thumbExtended) extendedCount++;
                    confidenceScore += thumbExtended ? 0.2 : 0;
                } else {
                    const fingerExtended = tip.y < joint.y - 0.05;
                    if (fingerExtended) extendedCount++;
                    confidenceScore += fingerExtended ? 0.2 : 0;
                }
            }
            
            const gestureMap = [
                'Fist',
                'One finger',
                'Two fingers',
                'Three fingers',
                'Four fingers',
                'Five fingers'
            ];
            
            const handOpenness = calculateHandOpenness(landmarks);
            confidenceScore += handOpenness * 0.3;
            
            return {
                gesture: gestureMap[extendedCount] || 'Unknown',
                confidence: Math.min(confidenceScore, 1)
            };
        }
        
        function calculateHandOpenness(landmarks) {
            const palmPoints = [0, 5, 9, 13, 17];
            let totalDistance = 0;
            
            for (let i = 0; i < palmPoints.length; i++) {
                for (let j = i + 1; j < palmPoints.length; j++) {
                    const dx = landmarks[palmPoints[i]].x - landmarks[palmPoints[j]].x;
                    const dy = landmarks[palmPoints[i]].y - landmarks[palmPoints[j]].y;
                    totalDistance += Math.sqrt(dx * dx + dy * dy);
                }
            }
            
            return Math.min(totalDistance / 2, 1);
        }
        
        function setupMouseControl() {
            canvas.addEventListener('mousemove', (e) => {
                handDetected = true;
                smoothedHandPosition.x = e.clientX;
                smoothedHandPosition.y = e.clientY;
                currentGesture = "Mouse Control";
                gestureConfidence = 0.5;
                activePattern = 'follow';
                updateDisplay();
            });
            
            canvas.addEventListener('mouseleave', () => {
                handDetected = false;
                currentGesture = null;
                activePattern = 'idle';
                updateDisplay();
            });
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                handDetected = true;
                smoothedHandPosition.x = e.touches[0].clientX;
                smoothedHandPosition.y = e.touches[0].clientY;
                currentGesture = "Touch Control";
                gestureConfidence = 0.5;
                activePattern = 'follow';
                updateDisplay();
            }, { passive: false });
        }
        
        function updateDisplay() {
            document.getElementById('particleCounter').textContent = particles.length;
            document.getElementById('accuracyCounter').textContent = 
                gestureConfidence > 0.8 ? 'High' : gestureConfidence > 0.5 ? 'Medium' : 'Low';
            document.getElementById('trackingStatus').textContent = 
                handDetected ? 'Active' : 'Searching';
            document.getElementById('trackingStatus').style.color = 
                handDetected ? '#00ffaa' : '#ffaa00';
            document.getElementById('patternDisplay').textContent = activePattern;
            
            const gestureIcon = document.getElementById('gestureIcon');
            const gestureText = document.getElementById('gestureText');
            
            if (handDetected && currentGesture) {
                const icons = {
                    'Fist': '‚úä',
                    'One finger': 'üëÜ',
                    'Two fingers': '‚úåÔ∏è',
                    'Three fingers': 'ü§ü',
                    'Four fingers': 'üñêÔ∏è',
                    'Five fingers': 'üëê',
                    'Mouse Control': 'üñ±Ô∏è',
                    'Touch Control': 'üëÜ'
                };
                gestureIcon.textContent = icons[currentGesture] || 'üñêÔ∏è';
                gestureText.textContent = currentGesture;
                gestureText.style.color = '#00ffaa';
            } else {
                gestureIcon.textContent = 'üëã';
                gestureText.textContent = handDetected ? 'Processing...' : 'Show hand to camera';
                gestureText.style.color = handDetected ? '#ffaa00' : '#888888';
            }
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Reset particles to new bounds
            particles.forEach(p => {
                p.x = Math.random() * canvas.width;
                p.y = Math.random() * canvas.height;
            });
        });
        
        // Prevent context menu on right-click
        canvas.addEventListener('contextmenu', e => e.preventDefault());
    </script>
</body>
</html>
